# 2_테이터 탐색





## EDA 탐색적 데이터 분석



**탐색적 데이터 분석(Exploratory Data Analysis)** 는 모델링에 앞서 데이터를 살피는 모든 과정을 의미합니다.

대회를 시작하고, 대회가 끝날 때까지 계속 이뤄져야 하는 과정이기도 합니다.

우선 필요한 최소한의 라이브러리들만 불러서 데이터를 살펴보도록 하겠습니다.

- **이 노트북은 예시이기에 이런 식으로 고민을 하고, 이런 생각들을 해야겠다. 등의 포인트로 읽어주시면 됩니다.**
- **더 다양하고 깔끔한 EDA를 기대하겠습니다. :)**

> 추후 세미나에 **pandas**, **numpy**, **matplotlib**, **seaborn** 노트북을 공유할 예정이니 기대해주세요 :)

## 라이브러리 호출 및 I/O

In [1]:

```
# 데이터 분석 라이브러리
import numpy as np
import pandas as pd

# 시각화 라이브러리
import matplotlib as mpl
import matplotlib.pyplot as plt
import seaborn as sns

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))
        
sns.set_style("whitegrid")
/kaggle/input/kakr-4th-competition/train.csv
/kaggle/input/kakr-4th-competition/test.csv
/kaggle/input/kakr-4th-competition/sample_submission.csv
```

우선 데이터를 불러옵시다. 기본적으로 csv파일로 제공되는 정형데이터는 `pd.read_csv()`로 읽어옵니다.

In [2]:

```
train_data = pd.read_csv('/kaggle/input/kakr-4th-competition/train.csv')
test_data = pd.read_csv('/kaggle/input/kakr-4th-competition/test.csv')
```

## Pandas의 메서드로 보는 간단한 탐색

데이터를 불러온 후에는 기본적으로 어떤 형태의 데이터가 있는지 살펴볼 수 있으며 다음 메서드를 사용할 수 있습니다.

- `.head()` : 상위 5개, 괄호 안에 숫자로 개수 변경 가능
- `.tail()` : 하위 5개, 괄호 안에 숫자로 개수 변경 가능
- `.sample()` : 랜덤 5개, 괄호 안에 숫자로 개수 변경 가능

In [3]:

```
train_data.head()
```

Out[3]:

|      | Unnamed: 0 | age  | workclass | fnlwgt | education    | education_num | marital_status     | occupation        | relationship  | race  | sex    | capital_gain | capital_loss | hours_per_week | native_country | income |
| :--- | :--------- | :--- | :-------- | :----- | :----------- | :------------ | :----------------- | :---------------- | :------------ | :---- | :----- | :----------- | :----------- | :------------- | :------------- | :----- |
| 0    | 0          | 40   | Private   | 168538 | HS-grad      | 9             | Married-civ-spouse | Sales             | Husband       | White | Male   | 0            | 0            | 60             | United-States  | >50K   |
| 1    | 1          | 17   | Private   | 101626 | 9th          | 5             | Never-married      | Machine-op-inspct | Own-child     | White | Male   | 0            | 0            | 20             | United-States  | <=50K  |
| 2    | 2          | 18   | Private   | 353358 | Some-college | 10            | Never-married      | Other-service     | Own-child     | White | Male   | 0            | 0            | 16             | United-States  | <=50K  |
| 3    | 3          | 21   | Private   | 151158 | Some-college | 10            | Never-married      | Prof-specialty    | Own-child     | White | Female | 0            | 0            | 25             | United-States  | <=50K  |
| 4    | 4          | 24   | Private   | 122234 | Some-college | 10            | Never-married      | Adm-clerical      | Not-in-family | Black | Female | 0            | 0            | 20             | ?              | <=50K  |

데이터의 각 feature는 다음과 같은 의미를 가지고 있습니다. (data description에서 제공)

- `age` : 나이
- `workclass` : 고용 형태
- `fnlwgt` : 사람 대표성을 나타내는 가중치 (final weight의 약자)
- `education` : 교육 수준
- `education_num` : 교육 수준 수치
- `marital_status`: 결혼 상태
- `occupation` : 업종
- `relationship` : 가족 관계
- `race` : 인종
- `sex` : 성별
- `capital_gain` : 양도 소득
- `capital_loss` : 양도 손실
- `hours_per_week` : 주당 근무 시간
- `native_country` : 국적
- `income` : **수익 (예측해야 하는 값)**

현재 여러 가지 feature가 있는 것을 확인할 수 있으며, 각 feature에 대한 통합적인 정보는 2가지로 살펴볼 수 있습니다.

- `.info()`
- `.describe()`

In [4]:

```
train_data.info()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 26049 entries, 0 to 26048
Data columns (total 16 columns):
 #   Column          Non-Null Count  Dtype 
---  ------          --------------  ----- 
 0   Unnamed: 0      26049 non-null  int64 
 1   age             26049 non-null  int64 
 2   workclass       26049 non-null  object
 3   fnlwgt          26049 non-null  int64 
 4   education       26049 non-null  object
 5   education_num   26049 non-null  int64 
 6   marital_status  26049 non-null  object
 7   occupation      26049 non-null  object
 8   relationship    26049 non-null  object
 9   race            26049 non-null  object
 10  sex             26049 non-null  object
 11  capital_gain    26049 non-null  int64 
 12  capital_loss    26049 non-null  int64 
 13  hours_per_week  26049 non-null  int64 
 14  native_country  26049 non-null  object
 15  income          26049 non-null  object
dtypes: int64(7), object(9)
memory usage: 3.2+ MB
```

각 feature에 있는 데이터에 몇 개의 null이 있고, 각 데이터의 type을 확인할 수 있습니다.

`object`는 수치형이 아닌 자료형으로 이해하시면 되고 대부분 string입니다.

후에 `object`인 feature는 대부분의 머신러닝 모델에 직접적인 입력 값으로 사용할 수 없으니 전처리 과정이 필요합니다.

In [5]:

```
train_data.describe()
```

Out[5]:

|       | Unnamed: 0   | age          | fnlwgt       | education_num | capital_gain | capital_loss | hours_per_week |
| :---- | :----------- | :----------- | :----------- | :------------ | :----------- | :----------- | :------------- |
| count | 26049.000000 | 26049.000000 | 2.604900e+04 | 26049.000000  | 26049.00000  | 26049.000000 | 26049.000000   |
| mean  | 13024.000000 | 38.569235    | 1.903045e+05 | 10.088372     | 1087.68970   | 87.732734    | 40.443126      |
| std   | 7519.842917  | 13.671489    | 1.059663e+05 | 2.567610      | 7388.85469   | 403.230205   | 12.361850      |
| min   | 0.000000     | 17.000000    | 1.376900e+04 | 1.000000      | 0.00000      | 0.000000     | 1.000000       |
| 25%   | 6512.000000  | 28.000000    | 1.181080e+05 | 9.000000      | 0.00000      | 0.000000     | 40.000000      |
| 50%   | 13024.000000 | 37.000000    | 1.788660e+05 | 10.000000     | 0.00000      | 0.000000     | 40.000000      |
| 75%   | 19536.000000 | 48.000000    | 2.377350e+05 | 12.000000     | 0.00000      | 0.000000     | 45.000000      |
| max   | 26048.000000 | 90.000000    | 1.484705e+06 | 16.000000     | 99999.00000  | 4356.000000  | 99.000000      |

describe을 사용하면 수치형 데이터의 다음 통계값을 추출할 수 있습니다.

- `count` : 개수
- `mean` : 평균
- `std` : 표준 편차
- `min` : 최솟값
- `25%` : 제 1사분위값
- `50%` : 중앙값, 중위값
- `75%` : 제 3사분위값
- `max` : 최댓값

범주형 데이터의 경우 `include='O'`를 추가하여 확인할 수 있습니다.

In [6]:

```
train_data.describe(include='O')
```

Out[6]:

|        | workclass | education | marital_status     | occupation     | relationship | race  | sex   | native_country | income |
| :----- | :-------- | :-------- | :----------------- | :------------- | :----------- | :---- | :---- | :------------- | :----- |
| count  | 26049     | 26049     | 26049              | 26049          | 26049        | 26049 | 26049 | 26049          | 26049  |
| unique | 9         | 16        | 7                  | 15             | 6            | 5     | 2     | 41             | 2      |
| top    | Private   | HS-grad   | Married-civ-spouse | Prof-specialty | Husband      | White | Male  | United-States  | <=50K  |
| freq   | 18123     | 8433      | 11970              | 3304           | 10541        | 22315 | 17482 | 23371          | 19744  |

이 경우에는 **범주의 개수, 상위 범주, 빈도수** 등을 제공하고 있습니다.

그렇다면 각 범주형 데이터는 어떤 feature를 가지고 있는지 살펴보겠습니다.

In [7]:

```
for col in train_data.columns:
    if train_data[col].dtype == 'object':
        categories = train_data[col].unique()
        print(f'[{col}] ({len(categories)})')
        print('\n'.join(categories))
        print()
[workclass] (9)
Private
State-gov
?
Self-emp-not-inc
Local-gov
Federal-gov
Self-emp-inc
Without-pay
Never-worked

[education] (16)
HS-grad
9th
Some-college
Bachelors
11th
1st-4th
5th-6th
Assoc-acdm
10th
Prof-school
7th-8th
Masters
Assoc-voc
Doctorate
12th
Preschool

[marital_status] (7)
Married-civ-spouse
Never-married
Separated
Married-spouse-absent
Divorced
Widowed
Married-AF-spouse

[occupation] (15)
Sales
Machine-op-inspct
Other-service
Prof-specialty
Adm-clerical
Craft-repair
?
Handlers-cleaners
Farming-fishing
Exec-managerial
Transport-moving
Protective-serv
Tech-support
Priv-house-serv
Armed-Forces

[relationship] (6)
Husband
Own-child
Not-in-family
Unmarried
Wife
Other-relative

[race] (5)
White
Black
Asian-Pac-Islander
Other
Amer-Indian-Eskimo

[sex] (2)
Male
Female

[native_country] (41)
United-States
?
Mexico
Poland
Philippines
Puerto-Rico
Vietnam
Germany
Cuba
France
Ireland
El-Salvador
Guatemala
Haiti
Trinadad&Tobago
Jamaica
Canada
Taiwan
South
Columbia
Peru
Japan
Dominican-Republic
China
England
Iran
India
Nicaragua
Italy
Honduras
Thailand
Ecuador
Portugal
Hungary
Greece
Hong
Outlying-US(Guam-USVI-etc)
Cambodia
Scotland
Yugoslavia
Laos

[income] (2)
>50K
<=50K
```

이렇게 보면 아직 데이터에 대한 이해가 부족할 수 있으니 좀 더 쉽게 살펴볼 수 있게 시각화 라이브러리 matplotlib과 seaborn을 통해 더 살펴보겠습니다.

## 데이터의 분포를 살피는 시각화

데이터의 분포는 다음과 같이 살필 수 있습니다. 대표적인 몇 가지만 살펴보도록 하겠습니다.

- 범주형 : bar
- 수치형
  - 이산형 : bar
  - 연속형 : kdeplot, histogram
- 범주형 + 수치형 : boxplot, violinplot, etc
- 수치형 + 수치형 : scatter

> 이 외에도 다양한 방법이 존재하니 찾아보시는 것을 추천합니다.

### 범주형 데이터의 분포

그 전에 범주형 feature의 unique한 범주 개수를 세어보겠습니다.

In [8]:

```
for col in train_data.columns:
    if train_data[col].dtype == 'object':
        categories = train_data[col].unique()
        print(f'[{col}] ({len(categories)})')
[workclass] (9)
[education] (16)
[marital_status] (7)
[occupation] (15)
[relationship] (6)
[race] (5)
[sex] (2)
[native_country] (41)
[income] (2)
```

전반적으로 범주의 수가 많아 전처리 이전에는 2개 이상의 feature를 한 plot에서 보기에는 조금 효율성이 떨어질 것 처럼 보입니다. pandas의 `value_counts`를 사용하면 같은 범주의 개수를 쉽게 셀 수 있습니다.

In [9]:

```
train_data['sex'].value_counts()
```

Out[9]:

```
Male      17482
Female     8567
Name: sex, dtype: int64
```

그리고 이를 matplotlib으로 그릴 수도 있지만, seaborn을 사용하면 다음과 같이 그릴 수 있습니다.

In [10]:

```
fig, ax = plt.subplots(1, 1, figsize=(8, 6))
sns.countplot(x='sex', data=train_data)
plt.show()
```

![img](https://www.kaggleusercontent.com/kf/44601412/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..vNCe5OW4lvQFuwDyZpda2A.sJ2qCTSxx2kBaqBF9iIIRCxnoQY9b3JlVT1-rYfxT5CXUGGNihFsMFD_6Eznjh-UDUH3VHhUONFqhSlYg48EtMiNx7pz79wc4ZRDlarTXMrvbKK-cMUAvBIUs_Q73AK6hVsjmEJmsANr16SdXJ0HftBeQy0sAI3zU4tGJtJl0RjzNkYR__RSyBYsv4GriOxqjp3JcFpQtOrIWcj-S8wlJLGxmnbnXAgEHwL1cW2MQR7lx9dzuo623LWx3MmIPAyd_EHOZjVLBHwm5uzrWjR3jrP78wB0A-Ia1RHdnAs0PEWDcG85UqexbGvBtGOT7CrllJQT6UwNW5U3HJR5qtsdZ14QwEqgZleRGXiICcTitgSXtoiEoro9NexpeabW0-orB2XVhEpU8FgNTdC3B8N-AeyE_GMLj-1kJgajVJkzGdzbYQuBRED-f22D2uIWaoMdak_ZSyn0gWs1N39ATAvthLGgVTxq8F51TEONGwLfFyeNW-VMR3AO00ePyTv8ReXPlpRCsMvnynOxbUyfLHbLgmEwVIDHYI6nx4ogqmcZjcwI0dXba6T-I1mEGQ3U-wPvY5PVvh7hnYqMwuMMyDJt4s9JCbPHZ5PMxN5k8LiJb8pRJPIeccNXvZy-FUxj_c86vk4-d4J_IOdy-elunQaXPg.PYmcWv-_PNQUMkbbq9_nlg/__results___files/__results___23_0.png)

다음과 같이 custom 할 수도 있습니다.

- eda의 핵심은 본인, 그리고 타인의 가독성을 생각하며 작성하는 것입니다.
- 여백, 축, 공간, 텍스트 등의 내용을 활용하시면 됩니다.

In [11]:

```
fig, axes = plt.subplots(1, 2, figsize=(13, 7), sharey=True)

sns.countplot(x='sex', data=train_data, ax=axes[0], palette="Set2", edgecolor='black') 
sns.countplot(x='income', data=train_data, ax=axes[1], color='gray', edgecolor='black') 

# Margin & Label 조정
for ax in axes : 
    ax.margins(0.12, 0.15)
    ax.xaxis.label.set_size(12)
    ax.xaxis.label.set_weight('bold')

    
# figure title    
plt.suptitle('Categorical Distribution', 
             fontsize=17, 
             fontweight='bold',
             x=0.05, y=1.06,
             ha='left' # horizontal alignment
            ) 

plt.tight_layout()
plt.show()
```

![img](https://www.kaggleusercontent.com/kf/44601412/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..vNCe5OW4lvQFuwDyZpda2A.sJ2qCTSxx2kBaqBF9iIIRCxnoQY9b3JlVT1-rYfxT5CXUGGNihFsMFD_6Eznjh-UDUH3VHhUONFqhSlYg48EtMiNx7pz79wc4ZRDlarTXMrvbKK-cMUAvBIUs_Q73AK6hVsjmEJmsANr16SdXJ0HftBeQy0sAI3zU4tGJtJl0RjzNkYR__RSyBYsv4GriOxqjp3JcFpQtOrIWcj-S8wlJLGxmnbnXAgEHwL1cW2MQR7lx9dzuo623LWx3MmIPAyd_EHOZjVLBHwm5uzrWjR3jrP78wB0A-Ia1RHdnAs0PEWDcG85UqexbGvBtGOT7CrllJQT6UwNW5U3HJR5qtsdZ14QwEqgZleRGXiICcTitgSXtoiEoro9NexpeabW0-orB2XVhEpU8FgNTdC3B8N-AeyE_GMLj-1kJgajVJkzGdzbYQuBRED-f22D2uIWaoMdak_ZSyn0gWs1N39ATAvthLGgVTxq8F51TEONGwLfFyeNW-VMR3AO00ePyTv8ReXPlpRCsMvnynOxbUyfLHbLgmEwVIDHYI6nx4ogqmcZjcwI0dXba6T-I1mEGQ3U-wPvY5PVvh7hnYqMwuMMyDJt4s9JCbPHZ5PMxN5k8LiJb8pRJPIeccNXvZy-FUxj_c86vk4-d4J_IOdy-elunQaXPg.PYmcWv-_PNQUMkbbq9_nlg/__results___files/__results___25_0.png)

- 남성과 여성의 비율도 2:1 정도의 불균형
- 타겟값인 income도 약 3:1 정도의 불균형

인종과 국적도 어느 정도 유사한 feature로 보입니다. 우선 살펴보겠습니다.

하지만 미국 국적이 너무 많아 유의미한 시각적인 분석은 전처리를 거친 후 진행해야 할 것 같네요.

In [12]:

```
fig, axes = plt.subplots(1, 2, figsize=(20, 7), sharey=True)

sns.countplot(x='race', data=train_data, ax=axes[0], color="gray", edgecolor='black') 
sns.countplot(x='native_country', data=train_data, ax=axes[1], color='gray', edgecolor='black') 

# Margin & Label 조정
for ax in axes : 
    ax.margins(0.12, 0.15)
    ax.xaxis.label.set_size(12)
    ax.xaxis.label.set_weight('bold')

plt.setp(axes[1].xaxis.get_majorticklabels(), rotation=90 )    
    
# figure title    
plt.suptitle('Categorical Distribution 2', 
             fontsize=17, 
             fontweight='bold',
             x=0.05, y=1.06,
             ha='left' # horizontal alignment
            ) 

plt.tight_layout()
plt.show()
```

![img](https://www.kaggleusercontent.com/kf/44601412/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..vNCe5OW4lvQFuwDyZpda2A.sJ2qCTSxx2kBaqBF9iIIRCxnoQY9b3JlVT1-rYfxT5CXUGGNihFsMFD_6Eznjh-UDUH3VHhUONFqhSlYg48EtMiNx7pz79wc4ZRDlarTXMrvbKK-cMUAvBIUs_Q73AK6hVsjmEJmsANr16SdXJ0HftBeQy0sAI3zU4tGJtJl0RjzNkYR__RSyBYsv4GriOxqjp3JcFpQtOrIWcj-S8wlJLGxmnbnXAgEHwL1cW2MQR7lx9dzuo623LWx3MmIPAyd_EHOZjVLBHwm5uzrWjR3jrP78wB0A-Ia1RHdnAs0PEWDcG85UqexbGvBtGOT7CrllJQT6UwNW5U3HJR5qtsdZ14QwEqgZleRGXiICcTitgSXtoiEoro9NexpeabW0-orB2XVhEpU8FgNTdC3B8N-AeyE_GMLj-1kJgajVJkzGdzbYQuBRED-f22D2uIWaoMdak_ZSyn0gWs1N39ATAvthLGgVTxq8F51TEONGwLfFyeNW-VMR3AO00ePyTv8ReXPlpRCsMvnynOxbUyfLHbLgmEwVIDHYI6nx4ogqmcZjcwI0dXba6T-I1mEGQ3U-wPvY5PVvh7hnYqMwuMMyDJt4s9JCbPHZ5PMxN5k8LiJb8pRJPIeccNXvZy-FUxj_c86vk4-d4J_IOdy-elunQaXPg.PYmcWv-_PNQUMkbbq9_nlg/__results___files/__results___27_0.png)

이런 특성을 하나씩 살펴보며 후에 어떤 인코딩, 어떤 feature selection, feature engineering을 할 수 있을지 생각해봅시다.

비슷한 방식으로 `relationship`과 `marital_status`도 살펴볼 수 있습니다.

In [13]:

```
fig, axes = plt.subplots(1, 2, figsize=(20, 7), sharey=True)

sns.countplot(x='relationship', data=train_data, ax=axes[0], palette="Set2", edgecolor='black') 
sns.countplot(x='marital_status', data=train_data, ax=axes[1], palette='Set2', edgecolor='black') 

# Margin & Label 조정
for ax in axes : 
    ax.margins(0.12, 0.15)
    ax.xaxis.label.set_size(12)
    ax.xaxis.label.set_weight('bold')

plt.setp(axes[1].xaxis.get_majorticklabels(), rotation=50 )    
    
# figure title    
plt.suptitle('Categorical Distribution 2', 
             fontsize=17, 
             fontweight='bold',
             x=0.05, y=1.06,
             ha='left' # horizontal alignment
            ) 

plt.tight_layout()
plt.show()
```

![img](https://www.kaggleusercontent.com/kf/44601412/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..vNCe5OW4lvQFuwDyZpda2A.sJ2qCTSxx2kBaqBF9iIIRCxnoQY9b3JlVT1-rYfxT5CXUGGNihFsMFD_6Eznjh-UDUH3VHhUONFqhSlYg48EtMiNx7pz79wc4ZRDlarTXMrvbKK-cMUAvBIUs_Q73AK6hVsjmEJmsANr16SdXJ0HftBeQy0sAI3zU4tGJtJl0RjzNkYR__RSyBYsv4GriOxqjp3JcFpQtOrIWcj-S8wlJLGxmnbnXAgEHwL1cW2MQR7lx9dzuo623LWx3MmIPAyd_EHOZjVLBHwm5uzrWjR3jrP78wB0A-Ia1RHdnAs0PEWDcG85UqexbGvBtGOT7CrllJQT6UwNW5U3HJR5qtsdZ14QwEqgZleRGXiICcTitgSXtoiEoro9NexpeabW0-orB2XVhEpU8FgNTdC3B8N-AeyE_GMLj-1kJgajVJkzGdzbYQuBRED-f22D2uIWaoMdak_ZSyn0gWs1N39ATAvthLGgVTxq8F51TEONGwLfFyeNW-VMR3AO00ePyTv8ReXPlpRCsMvnynOxbUyfLHbLgmEwVIDHYI6nx4ogqmcZjcwI0dXba6T-I1mEGQ3U-wPvY5PVvh7hnYqMwuMMyDJt4s9JCbPHZ5PMxN5k8LiJb8pRJPIeccNXvZy-FUxj_c86vk4-d4J_IOdy-elunQaXPg.PYmcWv-_PNQUMkbbq9_nlg/__results___files/__results___29_0.png)

둘의 **관계**를 살펴도 유의미할 것으로 보입니다.

In [14]:

```
fig, axes = plt.subplots(1, 3, figsize=(20, 7), sharey=True)

sns.countplot(x='workclass', data=train_data, ax=axes[0], palette="Set2", edgecolor='black') 
sns.countplot(x='occupation', data=train_data, ax=axes[1], palette='Set2', edgecolor='black') 
sns.countplot(x='education', data=train_data, ax=axes[2], palette='Set2', edgecolor='black') 

# Margin & Label 조정
for idx, ax in enumerate(axes) : 
    ax.margins(0.12, 0.15)
    ax.xaxis.label.set_size(12)
    ax.xaxis.label.set_weight('bold')
    plt.setp(axes[idx].xaxis.get_majorticklabels(), rotation=90 )    
    
# figure title    
plt.suptitle('Categorical Distribution 3', 
             fontsize=17, 
             fontweight='bold',
             x=0.05, y=1.06,
             ha='left' # horizontal alignment
            ) 

plt.tight_layout()
plt.show()
```

![img](https://www.kaggleusercontent.com/kf/44601412/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..vNCe5OW4lvQFuwDyZpda2A.sJ2qCTSxx2kBaqBF9iIIRCxnoQY9b3JlVT1-rYfxT5CXUGGNihFsMFD_6Eznjh-UDUH3VHhUONFqhSlYg48EtMiNx7pz79wc4ZRDlarTXMrvbKK-cMUAvBIUs_Q73AK6hVsjmEJmsANr16SdXJ0HftBeQy0sAI3zU4tGJtJl0RjzNkYR__RSyBYsv4GriOxqjp3JcFpQtOrIWcj-S8wlJLGxmnbnXAgEHwL1cW2MQR7lx9dzuo623LWx3MmIPAyd_EHOZjVLBHwm5uzrWjR3jrP78wB0A-Ia1RHdnAs0PEWDcG85UqexbGvBtGOT7CrllJQT6UwNW5U3HJR5qtsdZ14QwEqgZleRGXiICcTitgSXtoiEoro9NexpeabW0-orB2XVhEpU8FgNTdC3B8N-AeyE_GMLj-1kJgajVJkzGdzbYQuBRED-f22D2uIWaoMdak_ZSyn0gWs1N39ATAvthLGgVTxq8F51TEONGwLfFyeNW-VMR3AO00ePyTv8ReXPlpRCsMvnynOxbUyfLHbLgmEwVIDHYI6nx4ogqmcZjcwI0dXba6T-I1mEGQ3U-wPvY5PVvh7hnYqMwuMMyDJt4s9JCbPHZ5PMxN5k8LiJb8pRJPIeccNXvZy-FUxj_c86vk4-d4J_IOdy-elunQaXPg.PYmcWv-_PNQUMkbbq9_nlg/__results___files/__results___31_0.png)

- education은 education_num과 함께 살펴보아야겠지만, 순서가 유의미한 데이터이니 축을 변경해야할 것 입니다.
- occupation의 경우, workclass와 연결할 수 있을 것 같습니다.
- education과 occupation은 영향이 있지 않을까요?

다음과 같은 내용을 살펴보며 모델링에 신경써보기 바랍니다.

## 수치형 데이터의 시각화

다음과 같은 수치형 데이터에서 일부만 살펴보겠습니다.

- age
- education_num
- capital_gain
- capital_loss
- hours_per_week
- fnlwgt

In [15]:

```
fig, ax = plt.subplots(1, 1, figsize=(10, 5))
ax.hist(train_data['age'], bins=10)
ax.set_ylim(0, 6000)
ax.set_title('Age Distribution')
plt.show()
```

![img](https://www.kaggleusercontent.com/kf/44601412/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..vNCe5OW4lvQFuwDyZpda2A.sJ2qCTSxx2kBaqBF9iIIRCxnoQY9b3JlVT1-rYfxT5CXUGGNihFsMFD_6Eznjh-UDUH3VHhUONFqhSlYg48EtMiNx7pz79wc4ZRDlarTXMrvbKK-cMUAvBIUs_Q73AK6hVsjmEJmsANr16SdXJ0HftBeQy0sAI3zU4tGJtJl0RjzNkYR__RSyBYsv4GriOxqjp3JcFpQtOrIWcj-S8wlJLGxmnbnXAgEHwL1cW2MQR7lx9dzuo623LWx3MmIPAyd_EHOZjVLBHwm5uzrWjR3jrP78wB0A-Ia1RHdnAs0PEWDcG85UqexbGvBtGOT7CrllJQT6UwNW5U3HJR5qtsdZ14QwEqgZleRGXiICcTitgSXtoiEoro9NexpeabW0-orB2XVhEpU8FgNTdC3B8N-AeyE_GMLj-1kJgajVJkzGdzbYQuBRED-f22D2uIWaoMdak_ZSyn0gWs1N39ATAvthLGgVTxq8F51TEONGwLfFyeNW-VMR3AO00ePyTv8ReXPlpRCsMvnynOxbUyfLHbLgmEwVIDHYI6nx4ogqmcZjcwI0dXba6T-I1mEGQ3U-wPvY5PVvh7hnYqMwuMMyDJt4s9JCbPHZ5PMxN5k8LiJb8pRJPIeccNXvZy-FUxj_c86vk4-d4J_IOdy-elunQaXPg.PYmcWv-_PNQUMkbbq9_nlg/__results___files/__results___34_0.png)

인구조사인만큼 17세부터 데이터가 시작하고 90세가 최고령임을 알 수 있습니다. 45세 부근에서 수가 훅 줄어드는 것을 볼 수 있습니다.

나이는 어떤 식으로 인코딩하면 좋을까요? 타이타닉 대회에서 사용하는 age_band로 나이 구간을 만들 수 있고, 다양한 방식을 생각해봅시다.

------

나머지 데이터도 이런 방식으로 EDA해보면 되겠죠?

- 더 깔끔하고
- 더 많은 내용을 담고
- 더 좋은 인사이트를 담는

EDA 노트북을 만들어 보는 것부터 여러분의 데이터 분석은 시작입니다.

## 대회 참가자 모두 화이팅 입니다!!

- 시각화 테크닉, 데이터 분석 방법론 등이 궁금하거나 논의하고 싶다면 discussion을 활용해주세요
- 그리고 좋은 노트북, 디스커션에는 upvote를 통해 성의를 표합시다.
- 상호 존중을 통해 좋은 캐글, 커뮤니티 문화를 만들어나갑시다.







# 목차

1. 데이터 시각화란?
2. EDA란?
3. 실전에선 어떤 툴을 쓰는가?
4. 데이터 시각화 (EDA) 가이드라인 with Python

```
이번 포스팅은 목차의 1, 2, 3을 다루는 오프닝입니다. 핵심은 목차의 4에서 다뤄집니다. 목차 4에서는 Jupyter Notebook에 예제 기반으로 작성된 가이드라인을 설명할 예정입니다. 각 상황별로 어떤 시각화 방식을 택하는 게 좋고 파이썬 코드는 어떻게 작성하면 되는지에 대한 매뉴얼입니다!
```

# 1. 데이터 시각화란?

회사에서 데이터를 다루는 사람들은 본인이 가지고 있는 데이터에 대한 스토리를, 보는 사람이 큰 노력을 들이지 않고도 이해할 수 있도록 스토리를 간결화하여 나타내는 능력이 중요합니다.

![img](https://miro.medium.com/max/1400/0*Qi_ovmGZ_u4UkRVT.jpg)

출처: https://infogram.com/page/data-visualization

데이터 사이언티스트들 대부분이 데이터 분석 자체에 필요한 새 지식과 신기술을 익히기에 바쁩니다. 그러나 그 신기술의 가치는 데이터 분석을 통해 나온 인사이트를 공유할 수 있을 때 발생합니다. 즉, 분석한 내용을 보여줄 도구와 방법 또한 데이터 사이언티스트로서 깊게 고민해야 하는 부분입니다.

## 개념

- 광범위하게 분산된 방대한 양의 자료를 분석해, 한 눈에 보고 이해할 수 있도록 도표나 차트 등으로 정리하는 것을 의미합니다.

## 목적

- 설득과 사실 확인을 목적으로 합니다.

## 보는 대상이 누구인가에 따라 달라지는 방식

- 직접 그래프를 더 탐색해보고 싶은 목적이 있는 대상에게는 동적인(interactive) 시각화 방식이 좋습니다.
- 더 탐색할 목적이 없고, 보고 싶은 정보가 명확한 대상에게는 정적인 그래프를 기반으로 작성한 후, 추가적인 내용이 궁금하면 대시보드로 가도록 유도하는 것이 좋습니다.

## 일반적인 시각화 방식

![img](https://miro.medium.com/max/60/1*qtWoRMUSYfwKh87CLLAWCg.png?q=20)

![img](https://miro.medium.com/max/875/1*qtWoRMUSYfwKh87CLLAWCg.png)

구글링을 하면 찾을 수 있는 일반적으로 알려진 정보 시각화 방법 표입니다. 사실 데이터 시각화 초심자로서는 표 안의 많은 단어가 낯설고, 시각화해야 할 데이터가 어느 범주에 해당하는지 조차 헷갈립니다. 그런 분들을 위해 다음 포스팅에 Jupyter notebook 기반으로 예제를 풀며 쉽게 실행하며 따라 할 수 있는 가이드라인을 업로드할 예정입니다. 기대해주세요!

# 2. EDA(Exploratory Data Analysis)란?

## 개념

- 말 그대로는 탐색적 데이터 분석으로 해석됩니다.
- 기본 도구는 도표(plot), 그래프(graph), 요약 통계(summary statistics)등을 사용합니다.
- 모든 변수의 분포를 도표화하고, 시계열 데이터를 도표화하며, 변수를 변환하고, 산점도 행렬을 이용하여 변수들의 대응 관계를 파악하며, 모든 변수의 요약 통계를 생성하는 등의 방식을 취합니다.
- 데이터를 체계적으로 둘러보는 하나의 방법입니다.

## 목적

- 변수 간 트렌드, 패턴, 관계 등을 찾고자 합니다.
- 데이터 분석 프로젝트 초기에 가설을 수립하기 위해 사용됩니다.
- 데이터 분석 프로젝트 초기에, 적절한 모델 및 기법의 선정을 지원합니다.

## EDA와 데이터 시각화의 차이

**용어 정리**

- EDA = process of gaining relevant knowledge about a complex system
- Data visualization = process of telling what you learned and what you want to communicate

**단계**

![img](https://miro.medium.com/max/60/0*38QYyDwq58S9Mtdu.jpg?q=20)

![img](https://miro.medium.com/max/688/0*38QYyDwq58S9Mtdu.jpg)

출처: https://www.mdpi.com/2220-9964/6/11/368/html

- EDA(Exploratory Data Analysis)는 연구의 초기 혹은 데이터 정제(Clean Data) 이후 단계에서 이루어집니다. EDA 단계에서 얻은 이해는 알고리즘의 발전을 지원하고, 성능을 향상 시키는 데에 사용할 수 있습니다.
- 반면 데이터 시각화(Data Visualization)는 분석 결과를 커뮤니케이션 하기 위해 연구의 마지막이자 의사결정 전 단계(Decision making)에서 주로 행해지는 방법론을 칭합니다.

**EDA의 구성 요소**

두 방법론의 차이에 대한 이해를 돕기 위해 두 방법론의 관계에 대해 더 자세히 알아보겠습니다. Velleman and Hoaglin (1981)이 탐색적 데이터 분석의 네 가지 기본 구성 요소를 다음과 같이 규정하였습니다. (출처: https://www.creative-wisdom.com/teaching/WBI/EDA.shtml)

- Data visualization
- Residual analysis
- Data transformation or re-expression
- Resistance procedures

이 구성 요소를 통해 살펴 보면, EDA는 데이터를 시각화하는 것 외로도 숫자를 다루는 요소도 포함되어 있습니다. 이 규정을 참고하여 데이터 시각화와 탐색적 데이터 분석의 차이를 정의해보자면,

> ***“데이터 시각화(Data visualization)\****는 주로, 연구 후 분석 결과를 Communicate 하는 목적의 데이터 시각화를 칭하는 용어로 사용되는 경향이 있으나,* ***탐색적 데이터 분석(EDA)\****에서도 데이터 시각화를 주 방법론으로 사용한다”*

위와 같이 정의할 수 있겠습니다. 본 포스팅에서는 커뮤니케이션을 위한 데이터 시각화보다는, EDA 과정 내에서의 데이터 시각화에 대한 가이드라인을 다룹니다.

# 3. 실전에서는 어떤 툴을 쓰는가?

데이터 시각화 가이드라인으로 들어가기 전에, 실전에서는 어떤 툴을 쓰는지 짧게 소개하고자 합니다. 회사마다 다르겠으나, 필자가 일하던 곳에서는 Tableau, Google spreadsheet, Python을 가장 많이 사용하였습니다. 용도별로 실전 툴을 구분해 보았습니다.

## 빠른 커뮤니케이션이 중요할 때 (일회성으로 자료 뽑아 보여주고 재활용하지 않을 때)

- Excel
- Google Spreadsheet
- Python

## 대시보드로 생성할 때

- Tableau
- Google Spreadsheet
- Zepplin

## 심화된 데이터 전처리 혹은 모델링과 함께 섞을 때

- Python (Matplotlib, Seaborn, Folium, Pyecharts, Plotly, and etc.)
- R
- SQL
- Interactive EDA(Ipywidget, Colabotory의 경우 Widget)





## EDA

: Exploratory Data Analysis

- Main Point
  - Data Analysis
  - Inlier/Outlier
  - Feature Engineering
    - Feature Selection
    - Dimension Reduction
    - Feature Generation
- Libraries
  - Visualization
    - matplotlib
    - bokeh:
    - seaborn (as sns)
      - heatmap
        - variable/feature 간의 correlation matrix를 그릴 때 많이 사용됨.
      - pointplot, boxplot, lmplot(=scatterplot)
    - plotly
      - dots, lines, bars, pie, ...
